
- Makefile ✅ [PENDIENTE TESTS DE RELINK]
- Pipeline ✅ [Hace falta optimizar el codigo para simplificarlo]
- QUOTES
	- "$"AAA -> lo convierte a $AAA y intenta expandir la variable, se tiene que quedar como $AAA ❌
- Redirections
	-RED_IN ✅
		- En archivos sin permisos Permission denied no controlado ✅
		- < test.c da SEGV EN exec_cmd ✅
		- < out cata | ls cuando si existe el DOC, DEBE DAR !MENSAJE DE ERROR! DE CATA Y NO DE LS  ✅
		- cat < asd | cat Makefile | ls | cat < asd NO FUNVIONA igual ❌

			+ en caso de error de permisos falla, nuestra ejecucion da los dos mensajes
			+ de error correspondientes, pero luego muestra el ls (que no deberia)
			+ y deja el cat abierto

			= Tratar de evitar la ejecucion del comando en caso de error con el archvio por permisos
			= o q no exista

		- cat Makefile | cat < asd | ls ROMPE EL PROGRAMA ✅
		- cat < | queda el cat abierto ✅
		- < ouat cata | ls cuando NO existe el DOC, debej ejecutar el segundo comando y no lo hace  ✅
	-RED_OUT

		- ⬇️ cat test > no_permission  | wc DEBE EJECUTAR SEGUNDO COMANDO Y NO LO HACE ❌ ⬇️

			+ La salida del STD_OUT es incorrecta ya que el executor toma los dos tokens
			+ de tipo WORD y los ejecuta, despues de redirigir la salida al archivo y fallar
			+ el open, deberia redirigir algo incorrecto al extremo de escritura en la tuberia?


		- cata > asd | ls DEBE DAR !MENSAJE DE ERROR! DE CATA Y NO DE LS  ✅
		-[SOLVED✅] este caso cat tests/test.c > tet | cat tests/test3 no funciona igual
		-[SOLVED✅] < here.txt cat | wc > out.txt NO VA
		-[SOLVED✅] cat test.c > te | cat este tampoco 
		- ⬇️ cat > te | cat NO DA EXIT STATUS CORRECTO, BASH DA 0 Y NOSOTROS 130 ❌ ⬇️

			+ basicamente toma la interrupcion con cntrl+c y la setea al codigo puesto,
			+ deberia quedarse con 0 pero por que? es el primero comando o el segundo?

		- ⬇️ cat > tests/te | ca despues de interrupcion con ^C == exit_status 130, deberia ser 127 ❌ ⬇️

			+ pendiente de documentar el error
- Heredoc

	- [SOLVED✅]cat < tests/test << eof DEBE DAR PRIORIDAD DE REDIRECCION DE INPUT AL ULTIMO METACHAR, ya sea red_in o here_doc

		+ la funcion selector_input(t_parser *d); se encarga de poner en el STD_IN la redir de INPUT
		+ de mas a la derecha, ya sea here_doc o red_in

	- ⬇️ cat | ls | cat << adios no mantiene abierto el cat ❌ ⬇️

		+ ejecuta el cat, comunica tuberias, ejecuta ls, comunica tuberias y el here_doc 
		+ reestablece el std_in al original para poder usar la readline correctamente.
		+ deberia hacer "algo" para mantener abierto el cat?

- Append ❌ (NO IMPLEMENTADO)
- [SOLVED✅]Invalid cmd
- [SOLVED✅]rutas absolutas
- [SOLVED✅] ls -lR $HOME | wc 
- EXPANSOR ⏳
	- Expandir variables de entorno
	- El EXPANSOR no debe mantener strings como $varnoexist en la lista de tokens si no existen ❌ 
		- {$AAA} -> newline ✅
		- {$AAA cmd} -> ejecuta comando ✅
		- {cmd $AAA} -> ejecuta comando ✅
		- {echo $AAA $HOME} -> ignora $AAA y ejecuta {echo $HOME} ✅
		- {echho $HOME$} -> expande $HOME y deja el ulltimo $
	- solo un comando con '$' -> Printea 'command not found', deberia ser 'is a directory' ❌
	- OTRAS EXPANSIONES (En otros proyectos no estan implementadas ❓❓❓)
		- '$$' -> Debe expandir a PID ❌
		- '~' esto hay que expandirlo a la variable HOME ❌
- Implementar builtins ⏳
	|- BUILTINS
|     |- Echo (-n) ❌
		- echo -nnnnnnn hola debe mostrar hola sin newline 
		- echo -n -n -n -n -n hola debe mostrar hola sin newline 
		- echo -nnnnn -n -n -n hola debe mostrar hola sin newline
|     |-cd (relative/absolute path) ❌
		- cd - debe llevarte a tu OLDPWD
|	  |-pwd ✅
|	  |-export
|	  |-unset 
|	  |-env ✅
|	  |-exit ❌
		- exit 12 debe hacer exit con el numero pasado por parametro
		- exit 1234 24 no debe salir y muestra mensaje de error de "bash: exit: too many arguments" exit status en 1.
		- exit 1243a si sale con el numero 255 y muestra el mensaje de error bash: exit: 1243a: numeric argument required
- $? ✅
- ctrl-C, ctrl-D, ctrl-\ [❌  Hace falta optimizar el codigo para simplificarlo] 
	- ctrl-D dentro de child (cat) debe printear {Quit: 3} ✅
	- cat | cat | cat | cmd + ctrl-C -> pone exit_status en 130, deberia ser el return del ultimo cmd ❌

gcc src/mminishell.c libft/libft.a -lreadline -ltermcap

-L ~/.brew/opt/readline/lib -I ~/.brew/opt/readline/include //sin esto no pilla rl_replace_line



-----------------ACTUALIZAR READ_LINE----------------------

https://github.com/tjensen42/42-minishell

Dependencies
Install readline with brew
brew install readline
brew link --force readline
Add the path to the lib

Replace ~/.zshrc with ~/.bashrc if you use bash instead of zsh

echo 'export C_INCLUDE_PATH="/usr/local/opt/readline/include:$C_INCLUDE_PATH"' >> ~/.zshrc
echo 'export LIBRARY_PATH="/usr/local/opt/readline/lib:$LIBRARY_PATH"' >> ~/.zshrc
source ~/.zshrc


if (NO 42 HOME BREW)

Install readline on 42 Macs
Install Brew, only if it is not already installed:

rm -rf $HOME/.brew && git clone --depth=1 https://github.com/Homebrew/brew $HOME/.brew && echo 'export PATH=$HOME/.brew/bin:$PATH' >> $HOME/.zshrc && source $HOME/.zshrc && brew update
Install Readline library:

brew install readline
brew link --force readline
echo 'export C_INCLUDE_PATH="$HOME/.brew/include:$C_INCLUDE_PATH"' >> ~/.zshrc
echo 'export LIBRARY_PATH="$HOME/.brew/lib:$LIBRARY_PATH"' >> ~/.zshrc
source ~/.zshrc